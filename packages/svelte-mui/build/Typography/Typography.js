import { S as SvelteComponent, i as init, e as element, a as append, s as safe_not_equal, f as empty, h as insert, b as transition_out, j as check_outros, t as transition_in, k as detach, l as assign, o as exclude_internal_props, p as group_outros, q as create_slot, r as set_attributes, u as toggle_class, v as update_slot, w as get_spread_update } from '../index-b90fd758.js';

/* src/coffee/Typography/Typography.svelte generated by Svelte v3.29.4 */

function add_css() {
	var style = element("style");
	style.id = "svelte-18vtsie-style";
	style.textContent = ".root.svelte-18vtsie{margin:0;font-family:var(--font-family, var(--theme-typography-body1-font-family));font-weight:var(--font-weight, var(--theme-typography-body1-font-weight));font-size:var(--font-size, var(--theme-typography-body1-font-size));line-height:var(--line-height, var(--theme-typography-body1-line-height));letter-spacing:var(--letter-spacing, var(--theme-typography-body1-letter-spacing));text-transform:var(--text-transform, inherit)}.align-left.svelte-18vtsie{text-align:left}.align-center.svelte-18vtsie{text-align:center}.align-right.svelte-18vtsie{text-align:right}.align-justify.svelte-18vtsie{text-align:justify}.nowrap.svelte-18vtsie{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.gutter-bottom.svelte-18vtsie{margin-bottom:0.35em}.paragraph.svelte-18vtsie{margin-bottom:calc(var(--theme-spacing) * 2)}.color-inherit.svelte-18vtsie{color:inherit}.color-primary.svelte-18vtsie{color:var(--theme-palette-primary-main)}.color-secondary.svelte-18vtsie{color:var(--theme-palette-secondary-main)}.color-text-primary.svelte-18vtsie{color:var(--theme-palette-text-primary)}.color-text-secondary.svelte-18vtsie{color:var(--theme-palette-text-secondary)}.color-error.svelte-18vtsie{color:var(--theme-palette-error-main)}.display-inline.svelte-18vtsie{display:inline}.display-block.svelte-18vtsie{display:block}";
	append(document.head, style);
}

// (104:0) {:else}
function create_else_block(ctx) {
	let p;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let p_levels = [/*props*/ ctx[1]];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = assign(p_data, p_levels[i]);
	}

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			set_attributes(p, p_data);
			toggle_class(p, "svelte-18vtsie", true);
		},
		m(target, anchor) {
			insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(p, p_data = get_spread_update(p_levels, [dirty & /*props*/ 2 && /*props*/ ctx[1]]));
			toggle_class(p, "svelte-18vtsie", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (102:29) 
function create_if_block_4(ctx) {
	let h4;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let h4_levels = [/*props*/ ctx[1]];
	let h4_data = {};

	for (let i = 0; i < h4_levels.length; i += 1) {
		h4_data = assign(h4_data, h4_levels[i]);
	}

	return {
		c() {
			h4 = element("h4");
			if (default_slot) default_slot.c();
			set_attributes(h4, h4_data);
			toggle_class(h4, "svelte-18vtsie", true);
		},
		m(target, anchor) {
			insert(target, h4, anchor);

			if (default_slot) {
				default_slot.m(h4, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(h4, h4_data = get_spread_update(h4_levels, [dirty & /*props*/ 2 && /*props*/ ctx[1]]));
			toggle_class(h4, "svelte-18vtsie", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h4);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (100:29) 
function create_if_block_3(ctx) {
	let h3;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let h3_levels = [/*props*/ ctx[1]];
	let h3_data = {};

	for (let i = 0; i < h3_levels.length; i += 1) {
		h3_data = assign(h3_data, h3_levels[i]);
	}

	return {
		c() {
			h3 = element("h3");
			if (default_slot) default_slot.c();
			set_attributes(h3, h3_data);
			toggle_class(h3, "svelte-18vtsie", true);
		},
		m(target, anchor) {
			insert(target, h3, anchor);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(h3, h3_data = get_spread_update(h3_levels, [dirty & /*props*/ 2 && /*props*/ ctx[1]]));
			toggle_class(h3, "svelte-18vtsie", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h3);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (98:29) 
function create_if_block_2(ctx) {
	let h2;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let h2_levels = [/*props*/ ctx[1]];
	let h2_data = {};

	for (let i = 0; i < h2_levels.length; i += 1) {
		h2_data = assign(h2_data, h2_levels[i]);
	}

	return {
		c() {
			h2 = element("h2");
			if (default_slot) default_slot.c();
			set_attributes(h2, h2_data);
			toggle_class(h2, "svelte-18vtsie", true);
		},
		m(target, anchor) {
			insert(target, h2, anchor);

			if (default_slot) {
				default_slot.m(h2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(h2, h2_data = get_spread_update(h2_levels, [dirty & /*props*/ 2 && /*props*/ ctx[1]]));
			toggle_class(h2, "svelte-18vtsie", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (96:29) 
function create_if_block_1(ctx) {
	let h1;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let h1_levels = [/*props*/ ctx[1]];
	let h1_data = {};

	for (let i = 0; i < h1_levels.length; i += 1) {
		h1_data = assign(h1_data, h1_levels[i]);
	}

	return {
		c() {
			h1 = element("h1");
			if (default_slot) default_slot.c();
			set_attributes(h1, h1_data);
			toggle_class(h1, "svelte-18vtsie", true);
		},
		m(target, anchor) {
			insert(target, h1, anchor);

			if (default_slot) {
				default_slot.m(h1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(h1, h1_data = get_spread_update(h1_levels, [dirty & /*props*/ 2 && /*props*/ ctx[1]]));
			toggle_class(h1, "svelte-18vtsie", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (94:0) {#if component === 'p'}
function create_if_block(ctx) {
	let p;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let p_levels = [/*props*/ ctx[1]];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = assign(p_data, p_levels[i]);
	}

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			set_attributes(p, p_data);
			toggle_class(p, "svelte-18vtsie", true);
		},
		m(target, anchor) {
			insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(p, p_data = get_spread_update(p_levels, [dirty & /*props*/ 2 && /*props*/ ctx[1]]));
			toggle_class(p, "svelte-18vtsie", true);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_else_block
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*component*/ ctx[0] === "p") return 0;
		if (/*component*/ ctx[0] === "h1") return 1;
		if (/*component*/ ctx[0] === "h2") return 2;
		if (/*component*/ ctx[0] === "h3") return 3;
		if (/*component*/ ctx[0] === "h4") return 4;
		return 5;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	var classes, props, result, style;
	var { variant = "body1" } = $$props;
	var { component = "p" } = $$props;
	var { color = "initial" } = $$props;
	var { align = "inherit" } = $$props;
	var { display = "initial" } = $$props;
	var { nowrap = false } = $$props;
	var { gutterBottom = false } = $$props;
	var { paragraph = false } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("variant" in $$new_props) $$invalidate(2, variant = $$new_props.variant);
		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
		if ("color" in $$new_props) $$invalidate(3, color = $$new_props.color);
		if ("align" in $$new_props) $$invalidate(4, align = $$new_props.align);
		if ("display" in $$new_props) $$invalidate(5, display = $$new_props.display);
		if ("nowrap" in $$new_props) $$invalidate(6, nowrap = $$new_props.nowrap);
		if ("gutterBottom" in $$new_props) $$invalidate(7, gutterBottom = $$new_props.gutterBottom);
		if ("paragraph" in $$new_props) $$invalidate(8, paragraph = $$new_props.paragraph);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*variant, result*/ 4100) {
			 $$invalidate(13, style = ($$invalidate(12, result = `--font-family: var(--theme-typography-${variant}-font-family);
--font-weight: var(--theme-typography-${variant}-font-weight);
--font-size: var(--theme-typography-${variant}-font-size);
--line-height: var(--theme-typography-${variant}-line-height);
--letter-spacing: var(--theme-typography-${variant}-letter-spacing);`), variant === "overline"
			? $$invalidate(12, result += `--text-transform: var(--theme-typography-${//console.log 'style', result
				variant}-text-transform);`)
			: void 0, result));
		}

		if ($$self.$$.dirty & /*color, result, align, display, nowrap, gutterBottom, paragraph*/ 4600) {
			 $$invalidate(11, classes = ($$invalidate(12, result = ""), color !== "initial"
			? $$invalidate(12, result += `color-${color} `)
			: void 0, align !== "inherit"
			? $$invalidate(12, result += `align-${align} `)
			: void 0, display !== "initial"
			? $$invalidate(12, result += `display-${//console.log 'classes', result, color
				display} `)
			: void 0, nowrap ? $$invalidate(12, result += "nowrap ") : void 0, gutterBottom
			? $$invalidate(12, result += "gutter-bottom ")
			: void 0, paragraph
			? $$invalidate(12, result += "paragraph ")
			: void 0, result));
		}

		 $$invalidate(1, props = {
			class: `root ${classes} ${$$props.class}`,
			style: `${style} ${$$props.style}`
		});
	};

	$$props = exclude_internal_props($$props);

	return [
		component,
		props,
		variant,
		color,
		align,
		display,
		nowrap,
		gutterBottom,
		paragraph,
		$$scope,
		slots
	];
}

class Typography extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-18vtsie-style")) add_css();

		init(this, options, instance, create_fragment, safe_not_equal, {
			variant: 2,
			component: 0,
			color: 3,
			align: 4,
			display: 5,
			nowrap: 6,
			gutterBottom: 7,
			paragraph: 8
		});
	}
}

export default Typography;
